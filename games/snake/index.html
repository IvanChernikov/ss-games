<html>
<head>
	<title>Snake</title>
	<!-- BEGIN styles -->
	<link rel="stylesheet" href="/css/required.css">
	<link rel="stylesheet" href="/css/theme.css">
	<style>
body {
	background: black;
}
.game-container {
	max-width: 100vw;
	max-height: 100vh;
}
.game-window {
	max-width: 100vw;
	max-height: 100vh;
	object-fit: scale-down;
	background-color: rgba(40,40,40,1);
}
	</style>
	<!-- END styles -->
</head>
<body>
<!-- BEGIN content -->
<div class="container-fluid">
	<div class="row">
		<div class="col-12 d-flex justify-content-center game-container">
			<canvas class="game-window" width="800" height="600"></canvas>
		</div>
	</div>
</div>
<div class="modal fade" id="modal-start" tabindex="-1" role="dialog" aria-labelledby="modal-start-title" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="modal-start-title">Snake</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
			<p>Classic arcade Snake game written in javascript.</p>
			<p>Use the WASD keys to turn.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-success btn-block" data-dismiss="modal" onclick="game.start()">Start</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="modal-end" tabindex="-1" role="dialog" aria-labelledby="modal-end-title" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="modal-end-title">Snake</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
			<h2 class="text-center">GAME OVER</h2>
			<p>Your final score is <b id="game-score"></b></p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-success btn-block" data-dismiss="modal" onclick="location.reload()">Restart</button>
      </div>
    </div>
  </div>
</div>

<!-- END content -->
<!-- BEGIN scripts -->
<script src="/js/required.js"></script>
<script>
$('#modal-start').modal('show');
/*** RequestAnimationFrame Polyfill ***/
window.requestAnimationFrame = window.requestAnimationFrame
                               || window.mozRequestAnimationFrame
                               || window.webkitRequestAnimationFrame
                               || window.msRequestAnimationFrame
                               || function(f){return setTimeout(f, 1000/60)}

window.cancelAnimationFrame = window.cancelAnimationFrame
                              || window.mozCancelAnimationFrame
                              || function(requestID){clearTimeout(requestID)} //fall back
/*** APP ***/
function Sprite(img, width, height, positions){
	this.img = img;
	this.width = width;
	this.height = height;
	this.positions = positions;
}
Sprite.prototype = {
	draw: function(position, x, y){
		var pos = this.positions[position];
		draw.context.drawImage(
			this.img,
			pos[0],
			pos[1],
			this.width,
			this.height,
			x, y,
			config.grid,
			config.grid
		);
	}
};
config = {
	window: $('.game-window')[0],
	width: 20,
	height: 15,
	grid: 80,
	
	snake_can_burrow: true,
	snake_speed: 100
}
resource = {
	fruits: new Image(),
	load: function() {
		this.fruits.src = 'fruits.png';
	}
}
sprites = {
	fruits: new Sprite(
		resource.fruits,
		188, 188, [
			[6, 0], [212, 0], [418, 0],
			[6, 188], [212, 188], [418, 188],
			[6, 376], [212, 376], [418, 376]
		])
}

draw = {
	context: null,
	square: function (x, y, fill, stroke) {
		this.context.beginPath();
		this.context.fillStyle = fill;
		this.context.strokeStyle = stroke;
		this.context.rect(x, y, config.grid, config.grid);
		this.context.fill();
		this.context.stroke();
	},
	circle: function (x, y, r, fill, stroke) {
		this.context.beginPath();
		this.context.fillStyle = fill;
		this.context.strokeStyle = stroke;
		this.context.arc(x, y, r, 0, 2 * Math.PI);
		this.context.fill();
		this.context.stroke();
	},
	sprite: function (img, x, y, posX, posY, height, width, offsetX, offsetY) {
		offsetX = offsetX || 0;
		offsetY = offsetY || 0;
		this.context.drawImage(
			img,
			posX * height + offsetX,
			posY * width + offsetY,
			width,
			height,
			x, y,
			config.grid,
			config.grid
		);
	},
	snake: function (points, stroke) {
		this.context.beginPath();
		this.context.strokeStyle = stroke;
		this.context.lineWidth = config.grid / 2;
		let last = null
			reset = true;
		for (i in points) {
			let point = points[i]
				s = config.grid;
				
			if (last !== null) {
				if (Math.abs(last.x - point.x) > s*1.1) {
					this.context.strokeStyle = stroke;
					this.context.stroke();
					this.circle(0, last.y, s * 0.5, 'brown', 'transparent');
					this.circle(config.width * s, point.y, s * 0.5, 'brown', 'transparent');
					this.context.beginPath();
					reset = true;
				}
				if (Math.abs(last.y - point.y) > s*1.1) {
					this.context.strokeStyle = stroke;
					this.context.stroke();
					this.circle(last.x, 0, s * 0.5, 'brown', 'transparent');
					this.circle(point.x, config.height * s, s * 0.5, 'brown', 'transparent');
					this.context.beginPath();
					reset = true;
				}
			}
			if (reset) {
				this.context.moveTo(point.x, point.y);
				reset = false;
			} else {
				this.context.lineTo(point.x, point.y);
			}
			last = point;
		}
		this.context.strokeStyle = stroke;
		this.context.stroke();
	}
}

game = {
	snake: {
		// Direction in degrees
		direction: 0,
		x: 10,
		y: 10,
		dead: false,
		body: [
			[10,10],
			[9,10],
			[8,10]
		],
		draw: function (ctx) {
			let points = [];
			for (i in this.body) {
				let b = this.body[i],
					s = config.grid,
					x = b[0] * s + s/2,
					y = b[1] * s + s/2;
				points[i] = {x: x, y: y};
				//draw.square(x,y, 'green', 'black');
			}
			draw.snake(points, 'green');
		},
		move: function () {
			if (this.dead) return;
			// check if need to turn
			this.turn();
			// check direction
			switch (this.direction) {
				case 0:
					this.x += 1;
					break;
				case 90:
					this.y -= 1;
					break;
				case 180:
					this.x -= 1;
					break;
				case 270:
					this.y += 1;
					break;
			}
			// teleport if option set
			if (config.snake_can_burrow) {
				if (this.x >= config.width) {
					this.x = 0;
				}
				if (this.x < 0) {
					this.x = config.width;
				}
				if (this.y >= config.height) {
					this.y = 0;
				}
				if (this.y < 0) {
					this.y = config.height;
				}
			}
			// move head
			this.body.unshift([this.x, this.y]);
			
			// check collision with berry
			let ate_berry = null;
			for (i in game.berries) {
				let berry = game.berries[i];
				if (berry.x == this.x && berry.y == this.y) {
					ate_berry = i;
				}
			}
			if (ate_berry !== null) {
				// Eat berry
				game.berries.splice(ate_berry, 1);
				let free = false,
					x = 0,
					y = 0,
					sprite = Math.floor(Math.random() * sprites.fruits.positions.length);
				while (!free) {
					let collision = false;
					x = Math.floor(Math.random() * config.width);
					y = Math.floor(Math.random() * config.height);
					for (i in game.snake.body) {
						let s = game.snake.body[i];
						if (s[0] == x && s[1] == y) {
							collision = true;
							break;
						}
					}
					for (i in game.berries) {
						let b = game.berries[i];
						if (b.x == x && b.y == y) {
							collision = true;
							break;
						}
					}
					free = !collision;
				}
				game.berries.push({
					x: x,
					y: y,
					i: sprite
				});
				game.score ++;
			} else {
				// Remove last tail
				this.body.pop();
			}
			
			// check collision with self
			for (i in this.body) {
				let b = this.body[i];
				if (i != 0 && this.x == b[0] && this.y == b[1]) {
					this.dead = true;
					$('#modal-end').modal('show')
						.find('#game-score').text(game.score);
				}
			}
		},
		turn: function () {
			if (game.keys.w && (this.direction == 0 || this.direction == 180)) {
				this.direction = 90;
			}
			if (game.keys.a && (this.direction == 90 || this.direction == 270)) {
				this.direction = 180;
			}
			if (game.keys.s && (this.direction == 0 || this.direction == 180)) {
				this.direction = 270;
			}
			if (game.keys.d && (this.direction == 90 || this.direction == 270)) {
				this.direction = 0;
			}
		}
	},
	berries: [
		{x: 3, y: 3, i: 1 },
		{x: 14, y: 9, i: 4 }
	],
	score: 0,
	start: function() {
		
		game.resize();
		$(window).resize(game.resize);
		resource.load();
		draw.context = config.window.getContext('2d');
		
		this.time.last = performance.now();
		this.frame();
		// Create input buffer handler
		$(window).keydown(function (event) {
			if (typeof game.keys[event.key] !== 'undefined') {
				game.keys.reset();
				game.keys[event.key] = true;
			}
		});
	},
	resize: function () {
		let height = window.innerHeight,
			width = window.innerWidth;

		width = (width - (width % 20)) * 2;
		height = (height - (height % 15)) * 2;
		config.window.width = width;
		config.window.height = width / 20 * 15;

		config.grid = width / 20;
		
		widthStyle = config.grid /2 * 20 + 'px';
		heightStyle = config.grid / 2 * 15 + 'px';
		$(config.window).css('height', heightStyle)
			.css('width', widthStyle);
	},
	keys: {
		w: false,
		a: false,
		s: false,
		d: false,
		reset: function () {
			this.w = false;
			this.a = false;
			this.s = false;
			this.d = false;
		}
	},
	time: {
		current: 0,
		last: 0,
		step: 0.12,
		delta: 0,
		tick: function () {
			this.current = performance.now();
			this.delta += Math.min((this.current - this.last) / 1000);
		}
	},
	frame: function() {
		game.time.tick();
		
		while (game.time.delta > game.time.step) {
			game.time.delta -= game.time.step;
			game.update(game.time.delta);
		}
		
		game.draw(game.time.delta);
		
		game.time.last = game.time.current;
		window.requestAnimationFrame(game.frame);
	},
	update: function(delta) {
		game.snake.move();
	},
	draw: function (delta) {
		let ctx = draw.context;
		// Clear all
		ctx.clearRect(0,0,config.window.width, config.window.height);
		ctx.beginPath();
		ctx.fillStyle = 'beige';
		ctx.fillRect(0,0,config.window.width, config.window.height);
		ctx.imageSmoothingEnabled = false;
		// Draw snake
		game.snake.draw(ctx);
		// Draw berries
		ctx.lineCap = 'round';
		ctx.lineJoin = 'round';
		ctx.lineWidth = 2;
		for (i in game.berries) {
			let berry = game.berries[i]
				s = config.grid,
				x = berry.x * s,
				y = berry.y * s;
				sprites.fruits.draw(berry.i, x, y);
		}
	}
}
</script>
<!-- END scripts -->
</body>
</html>
